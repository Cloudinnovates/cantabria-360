<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - equirectangular panorama</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
            touch-action: none;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            color: #ffffff;
            padding: 5px;
            font-family: Monospace;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
        }

        a {
            color: #ffffff;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">
    <a href="http://threejs.org" target="_blank" rel="noopener">three.js webgl</a> - equirectangular panorama demo.
    photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank" rel="noopener">Jón
    Ragnarsson</a>.<br/>
    drag equirectangular texture into the page.
</div>

<script src="assets/javascript/lib/three.r102.js"></script>

<script>

  var camera, scene, renderer;

  var isUserInteracting = false,
    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
    lon = 0, onMouseDownLon = 0,
    lat = 0, onMouseDownLat = 0,
    phi = 0, theta = 0;

  const panoramas = [
    'assets/images/entrance.jpg',
    'assets/images/kitchen.jpg',
    'assets/images/bedroom.jpg',
    'assets/images/bathroom.jpg',
  ];
  let panoramaIndex = 0;

  initCube();
  init();
  animate();

  function initCube() {

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    // camera.position.z = 400;

    scene = new THREE.Scene();

    var texture = new THREE.TextureLoader().load( 'assets/images/crate.gif' );

    const crateMaterial = new THREE.SpriteMaterial({ map: texture });
    const crateSprite = new THREE.Sprite(crateMaterial);
    crateSprite.position.set(175, 0, -300);
    crateSprite.scale.set(50, 50, 1.0);
    scene.add(crateSprite);


    // add some text
    const textSprite = makeTextSprite(' Por aquí se va ');
    textSprite.position.set(200, 15, -300);
    scene.add(textSprite);
  }

  function init() {

    var container, mesh;

    container = document.getElementById('container');

    // camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
    camera.target = new THREE.Vector3(0, 0, 0);

    // scene = new THREE.Scene();

    var geometry = new THREE.SphereBufferGeometry(500, 60, 40);
    // var geometry = new THREE.SphereBufferGeometry(5000, 600, 400);
    // invert the geometry on the x-axis so that all of the faces point inward
    geometry.scale(-1, 1, 1);

    var material = new THREE.MeshBasicMaterial({
      map: new THREE.TextureLoader().load(panoramas[panoramaIndex])
    });

    mesh = new THREE.Mesh(geometry, material);

    scene.add(mesh);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    document.addEventListener('mousedown', onPointerStart, false);
    document.addEventListener('mousemove', onPointerMove, false);
    document.addEventListener('mouseup', onPointerUp, false);

    document.addEventListener('wheel', onDocumentMouseWheel, false);

    document.addEventListener('touchstart', onPointerStart, false);
    document.addEventListener('touchmove', onPointerMove, false);
    document.addEventListener('touchend', onPointerUp, false);

    //

    document.addEventListener('dragover', function (event) {

      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';

    }, false);

    document.addEventListener('dragenter', function () {

      document.body.style.opacity = 0.5;

    }, false);

    document.addEventListener('dragleave', function () {

      document.body.style.opacity = 1;

    }, false);

    document.addEventListener('drop', function (event) {

      event.preventDefault();

      var reader = new FileReader();
      reader.addEventListener('load', function (event) {

        material.map.image.src = event.target.result;
        material.map.needsUpdate = true;

      }, false);
      reader.readAsDataURL(event.dataTransfer.files[0]);

      document.body.style.opacity = 1;

    }, false);

    document.onkeyup = function(event){
      panoramaIndex = (panoramaIndex + 1) % panoramas.length
      material.map = THREE.ImageUtils.loadTexture(panoramas[panoramaIndex])
    }

    //

    window.addEventListener('resize', onWindowResize, false);

  }

  function makeTextSprite( message, parameters ) {
    if ( parameters === undefined ) parameters = {};

    var fontface = parameters.hasOwnProperty("fontface") ?
      parameters["fontface"] : "Arial";

    var fontsize = parameters.hasOwnProperty("fontsize") ?
      parameters["fontsize"] : 18;

    var borderThickness = parameters.hasOwnProperty("borderThickness") ?
      parameters["borderThickness"] : 4;

    var borderColor = parameters.hasOwnProperty("borderColor") ?
      parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };

    var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
      parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.font = "Bold " + fontsize + "px " + fontface;

    // get size data (height depends only on font size)
    var metrics = context.measureText( message );
    var textWidth = metrics.width;

    // background color
    context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
      + backgroundColor.b + "," + backgroundColor.a + ")";
    // border color
    context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
      + borderColor.b + "," + borderColor.a + ")";

    context.lineWidth = borderThickness;
    roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
    // 1.4 is extra height factor for text below baseline: g,j,p,q.

    // text color
    context.fillStyle = "rgba(0, 0, 0, 1.0)";

    context.fillText( message, borderThickness, fontsize + borderThickness);

    // canvas contents will be used for a texture
    var texture = new THREE.Texture(canvas)
    texture.needsUpdate = true;

    var spriteMaterial = new THREE.SpriteMaterial(
      { map: texture, useScreenCoordinates: false } );
    var sprite = new THREE.Sprite( spriteMaterial );
    sprite.scale.set(100,50,1.0);
    return sprite;
  }

  // function for drawing rounded rectangles
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function onPointerStart(event) {

    isUserInteracting = true;

    var clientX = event.clientX || event.touches[0].clientX;
    var clientY = event.clientY || event.touches[0].clientY;

    onMouseDownMouseX = clientX;
    onMouseDownMouseY = clientY;

    onMouseDownLon = lon;
    onMouseDownLat = lat;

  }

  function onPointerMove(event) {

    if (isUserInteracting === true) {

      var clientX = event.clientX || event.touches[0].clientX;
      var clientY = event.clientY || event.touches[0].clientY;

      lon = (onMouseDownMouseX - clientX) * 0.1 + onMouseDownLon;
      lat = (clientY - onMouseDownMouseY) * 0.1 + onMouseDownLat;

    }

  }

  function onPointerUp() {

    isUserInteracting = false;

  }

  function onDocumentMouseWheel(event) {

    var fov = camera.fov + event.deltaY * 0.05;

    camera.fov = THREE.Math.clamp(fov, 10, 75);

    camera.updateProjectionMatrix();

  }

  function animate() {

    requestAnimationFrame(animate);
    update();

  }

  function update() {

    if (isUserInteracting === false) {

      lon += 0.1;

    }

    lat = Math.max(-85, Math.min(85, lat));
    phi = THREE.Math.degToRad(90 - lat);
    theta = THREE.Math.degToRad(lon);

    camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
    camera.target.y = 500 * Math.cos(phi);
    camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);

    camera.lookAt(camera.target);

    /*
    // distortion
    camera.position.copy( camera.target ).negate();
    */

    renderer.render(scene, camera);

  }

</script>
</body>
</html>
